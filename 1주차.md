```
[ 1장 ]

<1-03> 가상환경 만들기 → C:\venvs> python -m venv {가상환경 이름}

<1-04> 쉽게 가상환경 이동하기 → “mysite.cmd” 생성

<1-05> 장고 프로젝트 만들기(mysite) C:\projects{이름}>django-admin startproject config .

<1-05> 인터프리터 가상환경 위치로 변경

서버실행 → (mysite) C:\projects\mysite>python manage.py runserver

setting.py 에 언어설정, 시간설치 (시크릿 키 확인)

프로젝트 생성시 기본파일

manage.py: 프로젝트 관리 명령어를 실행하는 스크립트.

settings.py: 프로젝트 설정을 정의하는 파일.

urls.py: URL 패턴을 정의하는 파일.

wsgi.py: WSGI 호환 웹 서버를 위한 진입점 파일.

asgi.py: ASGI 호환 웹 서버를 위한 진입점 파일.
```

```
<2-01>

앱생성 → (mysite) C:\projects\mysite>django-admin startapp {앱이름}

이건 http://localhost:8000/{앱이름} 요청시 응답

- 앱 생성시 기본 파일

- admin.py: Django 관리자 사이트와 관련된 설정을 정의하는 파일.

- apps.py: 앱의 설정을 정의하는 파일.

- models.py: 데이터베이스 모델을 정의하는 파일.

- tests.py: 테스트 케이스를 작성하는 파일.

- views.py: 뷰를 정의하는 파일.

- migrations/: 데이터베이스 마이그레이션 파일을 저장하는 디렉토리.

- 기타 초기화 파일(__init__.py 등).

프로젝트의 urls.py → URL과 앱의 뷰 함수간의 매핑 정의

페이지 요청시 가장 먼저 호출

즉, 1. URL 요청(웹 → 서버) / 2. urls.py 매핑확인 / 3. 매칭함수 결과(서버 → 웹)

**[urls.py]

from {앱} import views

urlpatterns = [

path('{앱}/', views.{함수}),

]

----------------------------------

[views.py]

from django.http import HttpResponse

def index(request):

return HttpResponse("ㅎㅇ.")

urls.py - 프로젝트 성격 / views.py - 앱 성격 → 앱 바뀔때마다 프로젝트 파일 바꾸는 것 좋지X

앱 만의 URL 매핑 파일 생성 필요

[프로젝트의 urls.py]

from django.urls import path, include

urlpatterns = [

path('{앱}/', include('{앱}.urls')),

]

------------------------------------------

[앱의 urls.py]

from django.urls import path

from . import views

urlpatterns = [

path('', views.{함수}),

]

이때 프로젝트의 urls.py 에서 {앱이름/} 매핑,

앱의 urls.py 에서 나머지 매핑되어 더해진 URL이 최종 URL

<2-02>

마이그레이션이란? DB데이터를 시스템에서 다른 시스템으로 이전하는 과정

setting.py 에 데베에 관한 내용도 나오네 우리 프로젝트의 BASE_DIR은 C:\projects\mysite SQLite는 소규모 프로젝트에서 사용되는 가벼운 파일 기반의 데베

DATABASES = {

'default': {

'ENGINE': 'django.db.backends.sqlite3',

'NAME': BASE_DIR / 'db.sqlite3',

}

}

데이터베이스가 필요한 앱만 migrate가 필요하다.

모델 (테이블을 모델) 장고 db models 를 가져와서 각 모델을 클래스로 만들고? 이름 / 속성 작성 여러가지 속성타입

• https://docs.djangoproject.com/en/4.0/ref/models/fields/#field-types

테이블 가져오려면

프로젝트 setting.py에 앱의 apps파일을 INSTALLED APPS 로 설정해줘야 함.

INSTALLED_APPS = [

'pybo.apps.PyboConfig',

python manage.py migrate 하기 전에

모델 변경, 생성 시 python manage.py makemigrations 해줘야 한다.

장고 쉘 실행 → python manage.py shell

from pybo.models import Question, Answer - 모델 가져오기

from django.utils import timezone - 시간 라이브러리? 가져오기

테이블 데이터(튜플) 생성

q = Question(subject='~~', content='~', create_date=timezone.now())

생성된 데이터 저장

q.save()

q.id - 값 조회

Question.objects.all() - 데이터 조회

Question.objects.filter(id=1) subject__contains='장고’ 등등 조건 확인

• https://docs.djangoproject.com/en/4.0/topics/db/queries/

모델에 특정 애트리뷰트 값을 데이터 조회 시 보이도록

def str(self):

return self.subject

모델 수정 / 삭제

q = Question.objects.get(id=2) - 변수에 저장

q.subject = 'Django Model Question’

q.save()

q.delete()

외래키 존재 시 연결 객체 이용

a = Answer(question=q, content='~', create_date=timezone.now())

연결 테이블 찾으려면

q.answer_set.all()

a.question

<2-03> Admin

관리자 생성 → python manage.py createsuperuser

http://localhost:8000/admin/ 접속

앱의 admin.py 파일

모델 등록

from .models import Question

admin.site.register(Question)

검색 클래스

class QuestionAdmin(admin.ModelAdmin):

search_fields = ['subject']

당연히 해당 클래스도 추가해야함

admin.site.register(Question, QuestionAdmin)

```

```
<2-04,5>

모델 사용 view 함수

이때 모델 값을 반환할 때는 딕셔너리 형태(아래코드의 context)로 넘겨줘야 한다.

from django.shortcuts import render, get_object_or_404

from .models import Question

def index(request):

question_list = Question.objects.order_by('-create_date') // - 는 역순

context = {'question_list' : question_list}

return render(request, 'pybo/question_list.html', context)

urls.py에서 값을 url에 주고 싶다면 <타입:변수명>

→ 이때 변수명은 views 함수의 인자명과 동일

urlpatterns = [

path('', views.index, name = 'index'), -> 별칭은 view, 템플릿에서 사용

path('<int:question_id>/', views.detail),

]

urls.py에 네임스페이스 설정 가능 → view, 템플릿에서 사용

프로젝트의 urls.py

path('pybo/', include('pybo.urls', namespace='pybo')),

앱의 urls.py

app_name = 'pybo’

사용예시

<li><a href="{% url 'pybo:detail' question.id %}">{{ question.subject }}</a></li>

<2-06>

POST기능의 함수

def answer_create(request, question_id):

question = get_object_or_404(Question, pk=question_id)

question.answer_set.create(content=request.POST.get('content'), create_date=timezone.now())

return redirect('pybo:detail', question_id=question.id)

request.POST.get('content') 이부분을 잘보면

템플릿의 post 타입 폼 답변 중 content 라는 데이터 값을 가져오는 것이다.

<2-10>

폼(Form) 이란?

쉽게 말해 페이지 요청시 전달되는 파라미터들을 쉽게 관리하기 위해 사용하는 클래스

필수 파라미터의 값이 누락되지 않았는지, 파라미터의 형식은 적절한지 등을 검증할 목적으로 사용한다.

(약간 모델에서 전달 부분만 가져 복제본 같은 느낌인가..?)

앱에 form.py 파일을 따로 만들어줘야 한다.

모델을 import하고 Meta로 필드지정

from django import forms

from pybo.models import Question

class QuestionForm(forms.ModelForm):

class Meta:

model = Question # 사용할 모델

fields = ['subject', 'content']

view에서 해당 Form 클래스를 가져와서 사용한다.

이때도 마찬가지로 템플릿으로 넘겨줄 땐 딕셔너리 형태

이렇게 넘겨주면 템플릿에서 해당 필드의 html 코드를 자동으로 생성

from .forms import QuestionForm

def question_create(request):

form = QuestionForm()

return render(request, 'pybo/question_form.html', {'form': form})

템플릿의 form 태그는 ‘GET’, ‘POST’ 요청방식(method) 중 하나로 action URL에 요청을 보낸다.

이때 action을 지정하지 않는다면? 현재 페이지로 요청을 보내게 된다.

즉, 같은 view 함수에 대해 GET, POST 요청방식의 URL 요청을 받을 수 있고,

요청방식에 따라 다르게 동작해야 할 수 있다.

(GET -처음 링크요청 / POST - 템플릿 form 의 submit)

def question_create(request):

if request.method == 'POST':

form = QuestionForm(request.POST)

if form.is_valid():

question = form.save(commit=False)

question.create_date = timezone.now()

question.save()

return redirect('pybo:index')

else:

form = QuestionForm()

context = {'form': form}

return render(request, 'pybo/question_form.html', context)

is_valid : form의 값이 유효한지 검사

commit = False : 임시저장, 즉 DB에 저장X → form에는 전체 속성이 있는 것이 아니기 때

Form의 위젯(부트스트랩 사용) / 레이블(속성 이름 설정) 도 있다.

필요할 때 코드를 찾아보기.
```
